# webpack 性能优化 
* 开发环境性能优化
* 生产环境性能优化

## 开发环境性能优化 
* 优化打包构建速度
* 优化代码调试 (source map)

## 生产环境性能优化

* 优化打包速度
* 优化代码的性能


* 在rules中使用 oneOf 
oneOf中的loader数组中的 test 只要命中一个文件类型就不会继续往下走,提高速度 但是同一文件使用2个以上loader 时候就不能利用 oneOf 了。需要将多余的loader 提出到 oneOf之外。

```javascript
rules : [
  {
    test : /\.js$/i,    //由于有两个js 文件 都放到oneOf 中会导致只匹配优先级高的那个loader (优先级可以通过enforce这个property 设置) 所以需要提取出来 
    loader : someLoader,
    enforce : "pre",
  },
  oneOf :[
    {
    test : /\.css$/i,
    loader : someLoader,
  },
  {
    test : /\.js$/i,
    loader : someLoader,
  },
  ]
]
```

* 从缓存角度优化
1. 生产环境下不使用webpack-dev-server 所以不能使用 HMR 功能

可以开启babel 缓存 第一次构建的时候把包缓存下来 如果第二次构建会读取缓存  
通过添加cacheDirectory:true 

```
{
  test : /\.js$/i,
  exclude : /node_modules/,
  loader : "babel-loader",
  options:{
    cacheDirectory : true,
  }

}
``` 

2. 给打包后的文件名添加hash值  [hash:10] 这样修改代码后hash改变就会重新请求了 如果没改变就直接走缓存。如果不使用hash 值打包后文件因为可能被强缓存 导致不回去请求被修改的文件 获取的是之前缓存的文件，通过修改文件名就行了。这个hash值是每次 webpack 
但是有一个存在的问题 资源都是共享了一个hash 值 也就是说一个文件的内容改变了所有的文件都会被修改名字 这导致所有的文件缓存都失效必须重新请求到，这显然是不好的方法 。 可以使用 [contenthash:10]  替代 hash
 contenthash ：不同的代码文件content 会生成不同的hash值
 ps：不能使用 chunkhash 因为很多文件都被引入同一个文件，所以属于同一个chunk，其chunkhash也是一样的。


 3. tree-shaking (去除没有被实际使用到的代码)
    满足条件：使用es6 module  开启 mode = "prodiuction"

 4. 代码分割(可以按需加载)
```
    entry : {
      // 多入口 就会生成多个bundle
      main : "./src/js/index.js",
      print : "./src/js/print.js",
    }
```